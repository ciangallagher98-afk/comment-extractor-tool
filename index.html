<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Comment Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-6">

    <div class="card w-full max-w-4xl mx-auto p-8 md:p-12">
        <div class="text-center mb-10">
            <div class="flex items-center justify-center">
                <svg class="title-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.625 9.75a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                <div>
                    <h1 class="text-3xl md:text-4xl font-bold text-gray-900">AI Comment Extractor</h1>
                    <p class="text-gray-500 mt-2">Upload a screenshot to turn comments into data.</p>
                </div>
            </div>
        </div>

        <!-- Instructions -->
        <div class="instructions-box bg-indigo-50 border-l-4 border-indigo-400 text-indigo-800 p-4 rounded-lg mb-8" role="alert">
            <p class="font-bold mb-2">How to Capture Comments:</p>
            <ol class="list-decimal list-inside text-sm space-y-1">
                <li>First, install the <a href="https://chromewebstore.google.com/detail/full-page-scrollable-area/lbndmgmpidplehmebcfkokbappanjmip?utm_source=ext_app_menu" target="_blank" rel="noopener noreferrer" class="font-semibold underline hover:text-indigo-600">Capture X browser extension</a>.</li>
                <li>On the social media post, scroll down to load all comments until no more appear.</li>
                <li>Scroll back to the top of the comments section.</li>
                <li>Use the "Capture X" extension and select the "Capture Scrollable Area" option.</li>
                <li>Select the scrollable area you want (comments).</li>
                <li>Upload the captured image below.</li>
            </ol>
        </div>

        <!-- Image Upload Form -->
        <div id="uploadContainer">
            <div id="dropZone" class="drop-zone w-full p-6 text-center rounded-lg cursor-pointer hover:bg-indigo-50">
                <input type="file" id="imageUpload" class="hidden" accept="image/png, image/jpeg" multiple>
                <svg class="drop-zone-icon mx-auto mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" /></svg>
                <p class="text-gray-600 font-semibold">Drag & drop screenshots here</p>
                <p class="text-gray-500 text-sm">or <span class="text-indigo-600 font-semibold">click to browse</span></p>
            </div>
            
            <div id="gallery-container" class="mt-6"></div>

            <button id="extractBtn" class="btn btn-primary mt-6 w-full flex items-center justify-center" disabled>
                <span id="btnText">Extract Comments</span>
                <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 h-6 w-6 ml-3 hidden"></div>
            </button>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="mt-10 hidden">
            <h2 class="text-2xl font-bold text-center mb-4">Extracted Comments</h2>
            <p id="statusText" class="text-center text-gray-600 mb-4"></p>
            
            <div id="sentimentSovContainer" class="hidden mb-6 p-4 border rounded-lg bg-gray-50">
                <h3 class="font-bold text-lg mb-3 text-center">Sentiment Share of Voice</h3>
                <div id="sovBars" class="space-y-3"></div>
            </div>

            <div id="resultsTableContainer" class="max-h-[30rem] overflow-y-auto border border-gray-200 rounded-lg"></div>
            
            <div id="actionButtons" class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-6">
                 <button id="sentimentBtn" class="btn btn-primary w-full sm:w-auto flex items-center justify-center">
                    <span id="sentimentBtnText">Analyze Sentiment</span>
                    <div id="sentimentLoader" class="loader ease-linear rounded-full border-4 border-t-4 h-6 w-6 ml-3 hidden"></div>
                </button>
            </div>

            <div id="pulsarSection" class="hidden mt-6">
                <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                    <h3 class="font-bold text-lg mb-3 text-center">Pulsar TRAC Details</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="pulsarApiKeyInput" class="block text-sm font-medium text-gray-700">Pulsar API Key</label>
                            <input type="password" id="pulsarApiKeyInput" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm" placeholder="Enter your Pulsar API Key">
                        </div>
                        <div>
                            <label for="targetSearchIdInput" class="block text-sm font-medium text-gray-700">Target Search ID</label>
                            <input type="text" id="targetSearchIdInput" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm" placeholder="Enter the ID of the search to update">
                        </div>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-6">
                     <button id="downloadCsvBtn" class="btn btn-success w-full sm:w-auto">Download CSV</button>
                     <button id="downloadSentimentBtn" class="btn btn-primary w-full sm:w-auto">Download Sentiment Report</button>
                     <button id="pulsarBtn" class="btn btn-pulsar w-full sm:w-auto flex items-center justify-center">
                        <span id="pulsarBtnText">Push to Pulsar TRAC</span>
                        <div id="pulsarLoader" class="loader ease-linear rounded-full border-4 border-t-4 h-6 w-6 ml-3 hidden"></div>
                    </button>
                </div>
            </div>
        </div>
        
        <div id="messageBox" class="hidden mt-6 px-4 py-3 rounded-lg relative" role="alert">
            <strong id="messageTitle" class="font-bold"></strong>
            <span id="messageText" class="block sm:inline"></span>
        </div>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const imageUpload = document.getElementById('imageUpload');
        const galleryContainer = document.getElementById('gallery-container');
        const extractBtn = document.getElementById('extractBtn');
        const btnText = document.getElementById('btnText');
        const loader = document.getElementById('loader');
        const resultsSection = document.getElementById('resultsSection');
        const statusText = document.getElementById('statusText');
        const resultsTableContainer = document.getElementById('resultsTableContainer');
        const actionButtons = document.getElementById('actionButtons');
        const sentimentBtn = document.getElementById('sentimentBtn');
        const sentimentBtnText = document.getElementById('sentimentBtnText');
        const sentimentLoader = document.getElementById('sentimentLoader');
        const sentimentSovContainer = document.getElementById('sentimentSovContainer');
        const sovBars = document.getElementById('sovBars');
        const pulsarSection = document.getElementById('pulsarSection');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const downloadSentimentBtn = document.getElementById('downloadSentimentBtn');
        const pulsarBtn = document.getElementById('pulsarBtn');
        const pulsarBtnText = document.getElementById('pulsarBtnText');
        const pulsarLoader = document.getElementById('pulsarLoader');
        const pulsarApiKeyInput = document.getElementById('pulsarApiKeyInput');
        const targetSearchIdInput = document.getElementById('targetSearchIdInput');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');

        let uploadedFiles = []; // Array to hold file objects {id, file, base64}
        let extractedComments = [];
        
        dropZone.addEventListener('click', () => imageUpload.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        imageUpload.addEventListener('change', (e) => handleFiles(e.target.files));
        extractBtn.addEventListener('click', handleExtractClick);
        sentimentBtn.addEventListener('click', handleSentimentClick);
        downloadCsvBtn.addEventListener('click', () => generateCSV(false));
        downloadSentimentBtn.addEventListener('click', () => generateCSV(true));
        pulsarBtn.addEventListener('click', handlePulsarClick);

        function handleFiles(files) {
            for (const file of files) {
                if (!file.type.startsWith('image/')) continue;
                
                const fileId = crypto.randomUUID();
                const reader = new FileReader();

                reader.onload = (e) => {
                    uploadedFiles.push({
                        id: fileId,
                        file: file,
                        base64: e.target.result.split(',')[1]
                    });
                    renderGallery();
                };
                reader.readAsDataURL(file);
            }
        }

        function renderGallery() {
            galleryContainer.innerHTML = '';
            uploadedFiles.forEach(fileObj => {
                const wrapper = document.createElement('div');
                wrapper.className = 'thumbnail-wrapper';
                
                const img = document.createElement('img');
                img.src = URL.createObjectURL(fileObj.file);
                img.className = 'thumbnail';

                const removeBtn = document.createElement('div');
                removeBtn.className = 'remove-img-btn';
                removeBtn.innerHTML = '&#x2715;'; // X symbol
                removeBtn.onclick = () => {
                    uploadedFiles = uploadedFiles.filter(f => f.id !== fileObj.id);
                    renderGallery();
                };

                wrapper.appendChild(img);
                wrapper.appendChild(removeBtn);
                galleryContainer.appendChild(wrapper);
            });
            extractBtn.disabled = uploadedFiles.length === 0;
        }

        async function handleExtractClick() {
            if (uploadedFiles.length === 0) {
                showMessage('Error', 'No images uploaded.', 'error');
                return;
            }
            setLoading(extractBtn, btnText, loader, true, 'Analyzing...');
            hideMessage();
            resetResults();
            extractedComments = [];

            try {
                for (const fileObj of uploadedFiles) {
                    const result = await callGeminiAPI(fileObj.base64);
                    const comments = result
                        .filter(comment => comment.text && comment.text.trim() !== '')
                        .map(comment => ({
                            ...comment,
                            timestamp: parseRelativeTime(comment.timestamp, new Date())
                        }));
                    extractedComments.push(...comments);
                }
                displayResults(extractedComments);
            } catch (error) {
                console.error('Extraction failed:', error);
                showMessage('Error', error.message, 'error');
            } finally {
                setLoading(extractBtn, btnText, loader, false, 'Extract Comments');
            }
        }
        
        async function handleSentimentClick() {
            if (extractedComments.length === 0) { return; }
            setLoading(sentimentBtn, sentimentBtnText, sentimentLoader, true, 'Analyzing...');
            try {
                const result = await callSentimentAPI(extractedComments);
                extractedComments.forEach((comment, index) => {
                    comment.sentiment = result.sentiments[index];
                });
                displayResults(extractedComments, true);
                displaySov(result.sov);
                actionButtons.classList.add('hidden');
                pulsarSection.classList.remove('hidden');
                pulsarSection.classList.add('fade-in-up');
            } catch (error) {
                showMessage('Error', error.message, 'error');
            } finally {
                setLoading(sentimentBtn, sentimentBtnText, sentimentLoader, false, 'Analyze Sentiment');
            }
        }

        async function handlePulsarClick() {
            const pulsarApiKey = pulsarApiKeyInput.value;
            const targetSearchId = targetSearchIdInput.value;
            if (!pulsarApiKey || !targetSearchId) {
                showMessage('Error', 'Please provide Pulsar API Key and Search ID.', 'error');
                return;
            }
            setLoading(pulsarBtn, pulsarBtnText, pulsarLoader, true, 'Pushing...');
            try {
                const comments = extractedComments.map(c => c.text);
                await pushToPulsar(comments, pulsarApiKey, targetSearchId);
                showMessage('Success', `Successfully pushed ${comments.length} comments to Pulsar.`, 'success');
            } catch (error) {
                showMessage('Error', `Failed to push to Pulsar. ${error.message}`, 'error');
            } finally {
                setLoading(pulsarBtn, pulsarBtnText, pulsarLoader, false, 'Push to Pulsar TRAC');
            }
        }

        async function fetchWithRetry(url, options, retries = 3) {
            try {
                const response = await fetch(url, options);
                if (response.status === 503 && retries > 0) {
                    await new Promise(res => setTimeout(res, (4 - retries) * 1000 * Math.random())); 
                    return fetchWithRetry(url, options, retries - 1);
                }
                return response;
            } catch (error) {
                if (retries > 0) {
                    await new Promise(res => setTimeout(res, (4 - retries) * 1000 * Math.random()));
                    return fetchWithRetry(url, options, retries - 1);
                }
                throw error;
            }
        }

        async function callGeminiAPI(imageData) {
            const apiKey = "AIzaSyDRo_7IcLRRKwqKhZtTE1-JtOu5Hb1ZRsY";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const prompt = `Analyze this screenshot from a social media feed. Identify each individual comment, the author, its relative timestamp (e.g., "1h", "2d ago"), and the number of likes (as a number, not text like "1.2k"). Return the data as a JSON object with a single key "comments". The value of "comments" should be an array of objects, where each object represents a single comment and has four keys: "author", "text", "timestamp", and "likes". If a value for likes is not visible, return 0. For example: { "comments": [{ "author": "user123", "text": "This is a great post!", "timestamp": "2h ago", "likes": 15 }] }. Do not include entries where the comment text is empty. If you cannot find any comments, return an empty array.`;
            const payload = {
                contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/png", data: imageData } }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "comments": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "author": { "type": "STRING" }, "text": { "type": "STRING" }, "timestamp": { "type": "STRING" }, "likes": { "type": "NUMBER" } }, "required": ["author", "text", "timestamp", "likes"] } } } } }
            };
            const response = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`AI service failed: ${await response.text()}`);
            const result = await response.json();
            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (jsonText) return JSON.parse(jsonText).comments;
            throw new Error('Could not find comments in the image.');
        }

        async function callSentimentAPI(comments) {
            const apiKey = "AIzaSyDRo_7IcLRRKwqKhZtTE1-JtOu5Hb1ZRsY";
            const commentTexts = comments.map(c => c.text);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const prompt = `Analyze the sentiment of the following list of comments. For each comment, classify it as 'Positive', 'Negative', or 'Neutral'. Also, provide an overall summary of the sentiment distribution as a "share of voice" (SOV). Return the data as a single JSON object with two keys: "sentiments" and "sov". The "sentiments" key should be an array of strings, one for each comment in the original order. The "sov" key should be an object with keys 'Positive', 'Negative', and 'Neutral', with their percentage values (as numbers, summing to 100). Example: { "sentiments": ["Positive", "Negative", "Neutral"], "sov": { "Positive": 60, "Negative": 25, "Neutral": 15 } }. Here are the comments: ${JSON.stringify(commentTexts)}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "sentiments": { "type": "ARRAY", "items": { "type": "STRING" } }, "sov": { "type": "OBJECT", "properties": { "Positive": { "type": "NUMBER" }, "Negative": { "type": "NUMBER" }, "Neutral": { "type": "NUMBER" } } } } } }
            };
            const response = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`Sentiment analysis failed: ${await response.text()}`);
            const result = await response.json();
            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (jsonText) return JSON.parse(jsonText);
            throw new Error("Could not parse sentiment response.");
        }

        async function pushToPulsar(comments, pulsarApiKey, targetSearchId) {
            const pulsarApiEndpoint = `https://api.pulsarplatform.com/v2/searches/${targetSearchId}/keywords`;
            const payload = { keywords_to_add: comments };
            const headers = { "Authorization": `Bearer ${pulsarApiKey}`, "Content-Type": "application/json" };
            const response = await fetch(pulsarApiEndpoint, { method: 'PUT', headers, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`Failed to fetch: ${await response.text()}`);
        }

        function displayResults(comments, withSentiment = false) {
            let tableHTML = `<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th class="px-6 py-3 text-left text-xs font-medium uppercase">Author</th><th class="px-6 py-3 text-left text-xs font-medium uppercase">Comment</th>`;
            if (withSentiment) {
                tableHTML += `<th class="px-6 py-3 text-left text-xs font-medium uppercase">Sentiment</th>`;
            }
            tableHTML += `<th class="px-6 py-3 text-left text-xs font-medium uppercase">Likes</th><th class="px-6 py-3 text-left text-xs font-medium uppercase">Timestamp</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            comments.forEach(comment => {
                tableHTML += `<tr><td class="px-6 py-4 text-sm font-medium">${escapeHTML(comment.author)}</td><td class="px-6 py-4 text-sm">${escapeHTML(comment.text)}</td>`;
                if (withSentiment) {
                    const color = comment.sentiment === 'Positive' ? 'text-green-600' : comment.sentiment === 'Negative' ? 'text-red-600' : 'text-gray-500';
                    tableHTML += `<td class="px-6 py-4 text-sm font-semibold ${color}">${escapeHTML(comment.sentiment)}</td>`;
                }
                 tableHTML += `<td class="px-6 py-4 text-sm">${escapeHTML(comment.likes)}</td><td class="px-6 py-4 text-sm">${escapeHTML(comment.timestamp)}</td></tr>`;
            });
            tableHTML += `</tbody></table>`;
            resultsTableContainer.innerHTML = tableHTML;
            statusText.textContent = `Successfully extracted ${comments.length} comments.`;
            resultsSection.classList.remove('hidden');
            resultsSection.classList.add('fade-in-up');
        }
        
        function displaySov(sov) {
            const colors = { Positive: 'bg-green-500', Negative: 'bg-red-500', Neutral: 'bg-gray-400' };
            sovBars.innerHTML = '';
            for (const [sentiment, value] of Object.entries(sov)) {
                const barWrapper = document.createElement('div');
                barWrapper.className = 'flex items-center text-sm';
                
                const label = document.createElement('span');
                label.className = 'w-24 font-semibold text-gray-700';
                label.textContent = `${sentiment}: ${value}%`;

                const bar = document.createElement('div');
                bar.className = 'w-full bg-gray-200 rounded-full h-4 ml-2';
                bar.innerHTML = `<div class="${colors[sentiment]} h-4 rounded-full" style="width: ${value}%"></div>`;
                
                barWrapper.appendChild(label);
                barWrapper.appendChild(bar);
                sovBars.appendChild(barWrapper);
            }
            sentimentSovContainer.classList.remove('hidden');
        }
        
        function resetUI() {
            uploadedFiles = [];
            renderGallery();
            resetResults();
        }

        function resetResults() {
            resultsSection.classList.add('hidden');
            sentimentSovContainer.classList.add('hidden');
            actionButtons.classList.remove('hidden');
            pulsarSection.classList.add('hidden');
            hideMessage();
        }

        function setLoading(btn, text, loader, isLoading, loadingText) {
            if (!text.dataset.original) text.dataset.original = text.textContent;
            btn.disabled = isLoading;
            text.textContent = isLoading ? loadingText : text.dataset.original;
            loader.classList.toggle('hidden', !isLoading);
        }
        
        function showMessage(title, text, type = 'error') {
            messageTitle.textContent = title;
            messageText.textContent = text;
            messageBox.className = `mt-6 p-4 rounded-lg fade-in-up ${type === 'error' ? 'bg-red-100 border border-red-400 text-red-700' : 'bg-green-100 border border-green-400 text-green-700'}`;
            messageBox.classList.remove('hidden');
        }

        function hideMessage() { messageBox.classList.add('hidden'); }
        function escapeHTML(str) { return String(str || '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]); }
        
        function parseRelativeTime(relativeString, referenceDate) {
            if (!relativeString) return "N/A";
            const now = new Date(referenceDate);
            const str = String(relativeString).toLowerCase().trim();
            let date = new Date(now);
            const matchers = [
                { regex: /(\d+)\s*s(ec)?/, unit: 'seconds' }, { regex: /(\d+)\s*m(in)?/, unit: 'minutes' },
                { regex: /(\d+)\s*h(r|our)?/, unit: 'hours' }, { regex: /(\d+)\s*d(ay)?/, unit: 'days' },
                { regex: /(\d+)\s*w(k|eek)?/, unit: 'weeks' }, { regex: /(\d+)\s*mo(nth)?/, unit: 'months' },
                { regex: /(\d+)\s*y(r|ear)?/, unit: 'years' }
            ];
            let matched = false;
            for (const { regex, unit } of matchers) {
                const match = str.match(regex);
                if (match) {
                    const value = parseInt(match[1], 10);
                    if (unit === 'seconds') date.setSeconds(date.getSeconds() - value);
                    if (unit === 'minutes') date.setMinutes(date.getMinutes() - value);
                    if (unit === 'hours') date.setHours(date.getHours() - value);
                    if (unit === 'days') date.setDate(date.getDate() - value);
                    if (unit === 'weeks') date.setDate(date.getDate() - value * 7);
                    if (unit === 'months') date.setMonth(date.getMonth() - value);
                    if (unit === 'years') date.setFullYear(date.getFullYear() - value);
                    matched = true;
                    break;
                }
            }
            if (str.includes("yesterday")) {
                date.setDate(date.getDate() - 1);
                matched = true;
            }
            if (!matched) {
                const parsedDate = new Date(str);
                if (!isNaN(parsedDate.getTime())) {
                    if (!/(\d{4})/.test(str)) {
                        parsedDate.setFullYear(now.getFullYear());
                        if (parsedDate > now) parsedDate.setFullYear(now.getFullYear() - 1);
                    }
                    date = parsedDate;
                } else { return relativeString; }
            }
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hour = String(date.getHours()).padStart(2, '0');
            const minute = String(date.getMinutes()).padStart(2, '0');
            const second = String(date.getSeconds()).padStart(2, '0');
            return `${day}/${month}/${year} ${hour}:${minute}:${second}`;
        }

        function generateCSV(withSentiment) {
            if (extractedComments.length === 0) {
                showMessage('Error', 'No comments to download.', 'error');
                return;
            }
            const escapeCSV = (field) => {
                if (field == null) return '';
                let str = String(field);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    str = str.replace(/"/g, '""');
                    return `"${str}"`;
                }
                return str;
            };
            
            const headers = ['Content ID', 'Date', 'Comment/Content', 'Author', 'Likes'];
            if (withSentiment) {
                headers.push('Sentiment');
            }

            const csvRows = [headers.join(',')];
            const commentsToExport = extractedComments.filter(comment => comment.text && comment.text.trim() !== '');

            commentsToExport.forEach(comment => {
                const contentId = crypto.randomUUID();
                const values = [
                    escapeCSV(contentId),
                    escapeCSV(comment.timestamp),
                    escapeCSV(comment.text),
                    escapeCSV(comment.author),
                    escapeCSV(comment.likes)
                ];
                if (withSentiment) {
                    values.push(escapeCSV(comment.sentiment || 'N/A'));
                }
                csvRows.push(values.join(','));
            });
            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = withSentiment ? 'sentiment-report.csv' : 'extracted-comments.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>

