<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Comment Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="styles.css">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-HD2YNJL1QG"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-HD2YNJL1QG');
    </script>
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-6">

    <div class="card w-full max-w-4xl mx-auto p-8 md:p-12">
        
        <div class="flex items-center justify-center text-center mb-10">
            <!-- Title icon -->
            <svg class="title-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.625 9.75a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            <div>
                <h1 class="text-3xl md:text-4xl font-bold text-gray-900">AI Comment Extractor</h1>
                <p class="text-gray-500 mt-2">Upload a screenshot to turn comments into data.</p>
            </div>
        </div>

        <!-- Instructions -->
        <div class="instructions-box bg-indigo-50 border-l-4 border-indigo-400 text-indigo-800 p-4 rounded-lg mb-8" role="alert">
            <p class="font-bold mb-2">How to Capture Comments:</p>
            <ol class="list-decimal list-inside text-sm space-y-1">
                <li>First, install the <a href="https://chromewebstore.google.com/detail/full-page-scrollable-area/lbndmgmpidplehmebcfkokbappanjmip?utm_source=ext_app_menu" target="_blank" rel="noopener noreferrer" class="font-semibold underline hover:text-indigo-600">Capture X browser extension</a>.</li>
                <li>On the social media post, scroll down to load all comments until no more appear.</li>
                <li>Scroll back to the top of the comments section.</li>
                <li>Use the "Capture X" extension and select the "Capture Scrollable Area" option.</li>
                <li>Select the scrollable area you want (comments).</li>
                <li>Upload the captured image below.</li>
            </ol>
        </div>

        <!-- Image Upload Form -->
        <div id="uploadContainer">
            <div id="dropZone" class="drop-zone w-full p-8 text-center rounded-lg cursor-pointer hover:bg-indigo-50">
                <input type="file" id="imageUpload" class="hidden" accept="image/png, image/jpeg">
                <svg class="drop-zone-icon mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" /></svg>
                <p class="text-gray-500">Drag & drop your screenshot here, or <span class="text-indigo-600 font-semibold">click to upload</span></p>
            </div>
            <div id="imagePreviewContainer" class="mt-6 text-center hidden">
                <img id="imagePreview" class="rounded-lg mx-auto shadow-md" src="" alt="Image preview">
                <button id="removeImageBtn" class="mt-4 text-sm text-red-500 hover:text-red-700 font-semibold">Remove Image</button>
            </div>
            <button id="extractBtn" class="btn btn-primary mt-6 w-full flex items-center justify-center" disabled>
                <span id="btnText">Extract Comments</span>
                <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 h-6 w-6 ml-3 hidden"></div>
            </button>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="mt-10 hidden">
            <h2 class="text-2xl font-bold text-center mb-4">Extracted Comments</h2>
            <p id="statusText" class="text-center text-gray-600 mb-4"></p>
            
            <!-- Sentiment SOV Display -->
            <div id="sentimentSovContainer" class="hidden mb-6 p-4 border rounded-lg bg-gray-50">
                <h3 class="font-bold text-lg mb-3 text-center">Sentiment Share of Voice</h3>
                <div id="sovBars" class="space-y-2"></div>
            </div>

            <div id="resultsTableContainer" class="max-h-96 overflow-y-auto border border-gray-200 rounded-lg">
                <!-- Table will be populated here -->
            </div>
            
            <!-- Action Buttons -->
            <div id="actionButtons" class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-6">
                 <button id="sentimentBtn" class="btn btn-primary w-full sm:w-auto flex items-center justify-center">
                    <span id="sentimentBtnText">Analyze Sentiment</span>
                    <div id="sentimentLoader" class="loader ease-linear rounded-full border-4 border-t-4 h-6 w-6 ml-3 hidden"></div>
                </button>
            </div>

            <!-- Pulsar Credentials Input -->
            <div id="pulsarSection" class="hidden mt-6">
                <div id="pulsarCredentials" class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                    <h3 class="font-bold text-lg mb-3 text-center">Pulsar TRAC Details</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="pulsarApiKeyInput" class="block text-sm font-medium text-gray-700">Pulsar API Key</label>
                            <input type="password" id="pulsarApiKeyInput" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="Enter your Pulsar API Key">
                        </div>
                        <div>
                            <label for="targetSearchIdInput" class="block text-sm font-medium text-gray-700">Target Search ID</label>
                            <input type="text" id="targetSearchIdInput" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="Enter the ID of the search to update">
                        </div>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mt-6">
                     <button id="downloadCsvBtn" class="btn btn-success w-full sm:w-auto">Download CSV</button>
                     <button id="downloadSentimentBtn" class="btn btn-primary w-full sm:w-auto">Download Sentiment Report</button>
                     <button id="pulsarBtn" class="btn btn-pulsar w-full sm:w-auto flex items-center justify-center">
                        <span id="pulsarBtnText">Push to Pulsar TRAC</span>
                        <div id="pulsarLoader" class="loader ease-linear rounded-full border-4 border-t-4 h-6 w-6 ml-3 hidden"></div>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Message/Error Box -->
        <div id="messageBox" class="hidden mt-6 px-4 py-3 rounded-lg relative" role="alert">
            <strong id="messageTitle" class="font-bold"></strong>
            <span id="messageText" class="block sm:inline"></span>
        </div>

    </div>

    <script>
        // DOM Elements
        const uploadContainer = document.getElementById('uploadContainer');
        const dropZone = document.getElementById('dropZone');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const removeImageBtn = document.getElementById('removeImageBtn');
        const extractBtn = document.getElementById('extractBtn');
        const btnText = document.getElementById('btnText');
        const loader = document.getElementById('loader');
        const resultsSection = document.getElementById('resultsSection');
        const statusText = document.getElementById('statusText');
        const resultsTableContainer = document.getElementById('resultsTableContainer');
        const actionButtons = document.getElementById('actionButtons');
        const sentimentBtn = document.getElementById('sentimentBtn');
        const sentimentBtnText = document.getElementById('sentimentBtnText');
        const sentimentLoader = document.getElementById('sentimentLoader');
        const sentimentSovContainer = document.getElementById('sentimentSovContainer');
        const sovBars = document.getElementById('sovBars');
        const pulsarSection = document.getElementById('pulsarSection');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const downloadSentimentBtn = document.getElementById('downloadSentimentBtn');
        const pulsarBtn = document.getElementById('pulsarBtn');
        const pulsarBtnText = document.getElementById('pulsarBtnText');
        const pulsarLoader = document.getElementById('pulsarLoader');
        const pulsarApiKeyInput = document.getElementById('pulsarApiKeyInput');
        const targetSearchIdInput = document.getElementById('targetSearchIdInput');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');

        let extractedComments = [];
        let base64ImageData = null;
        let imageUploadTime = null;

        // --- Event Listeners ---
        dropZone.addEventListener('click', () => imageUpload.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
        });
        imageUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleFile(e.target.files[0]);
        });
        removeImageBtn.addEventListener('click', resetUI);
        extractBtn.addEventListener('click', handleExtractClick);
        sentimentBtn.addEventListener('click', handleSentimentClick);
        downloadCsvBtn.addEventListener('click', () => generateCSV(false));
        downloadSentimentBtn.addEventListener('click', () => generateCSV(true));
        pulsarBtn.addEventListener('click', handlePulsarClick);

        // --- Core Functions ---
        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showMessage('Error', 'Please upload an image file (PNG, JPG).', 'error');
                return;
            }
            imageUploadTime = new Date();
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                base64ImageData = e.target.result.split(',')[1];
                imagePreviewContainer.classList.remove('hidden');
                extractBtn.disabled = false;
                hideMessage();
            };
            reader.readAsDataURL(file);
        }

        async function handleExtractClick() {
            if (!base64ImageData) {
                showMessage('Error', 'No image uploaded.', 'error');
                return;
            }
            setLoading(extractBtn, btnText, loader, true, 'Analyzing...');
            hideMessage();
            resetResults();

            try {
                const result = await callGeminiAPI(base64ImageData);
                extractedComments = result
                    .filter(comment => comment.text && comment.text.trim() !== '')
                    .map(comment => ({
                        ...comment,
                        timestamp: parseRelativeTime(comment.timestamp, imageUploadTime)
                    }));
                displayResults(extractedComments);
            } catch (error) {
                console.error('Extraction failed:', error);
                showMessage('Error', error.message, 'error');
            } finally {
                setLoading(extractBtn, btnText, loader, false, 'Extract Comments');
            }
        }
        
        async function handleSentimentClick() {
            if (extractedComments.length === 0) {
                showMessage('Error', 'No comments to analyze.', 'error');
                return;
            }
            setLoading(sentimentBtn, sentimentBtnText, sentimentLoader, true, 'Analyzing...');
            hideMessage();

            try {
                const result = await callSentimentAPI(extractedComments);
                extractedComments.forEach((comment, index) => {
                    comment.sentiment = result.sentiments[index];
                });
                displayResults(extractedComments, true);
                displaySov(result.sov);
                actionButtons.classList.add('hidden');
                pulsarSection.classList.remove('hidden');
                pulsarSection.classList.add('fade-in-up');
            } catch (error) {
                console.error('Sentiment analysis failed:', error);
                showMessage('Error', error.message, 'error');
            } finally {
                setLoading(sentimentBtn, sentimentBtnText, sentimentLoader, false, 'Analyze Sentiment');
            }
        }

        async function handlePulsarClick() {
            const pulsarApiKey = pulsarApiKeyInput.value;
            const targetSearchId = targetSearchIdInput.value;

            if (extractedComments.length === 0) {
                showMessage('Error', 'No comments to push.', 'error');
                return;
            }
            if (!pulsarApiKey || !targetSearchId) {
                showMessage('Error', 'Please provide your Pulsar API Key and Target Search ID.', 'error');
                return;
            }

            setLoading(pulsarBtn, pulsarBtnText, pulsarLoader, true, 'Pushing...');
            hideMessage();

            try {
                const comments = extractedComments.map(c => c.text);
                await pushToPulsar(comments, pulsarApiKey, targetSearchId);
                showMessage('Success', `Successfully pushed ${comments.length} comments to your Pulsar TRAC search.`, 'success');
            } catch (error) {
                console.error('Pulsar push failed:', error);
                showMessage('Error', `Failed to push to Pulsar. ${error.message}`, 'error');
            } finally {
                setLoading(pulsarBtn, pulsarBtnText, pulsarLoader, false, 'Push to Pulsar TRAC');
            }
        }

        // --- API Communication ---
        async function callGeminiAPI(imageData) {
            const apiKey = "AIzaSyDRo_7IcLRRKwqKhZtTE1-JtOu5Hb1ZRsY";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const prompt = `Analyze this screenshot from a social media feed. Identify each individual comment, the author, its relative timestamp (e.g., "1h", "2d ago"), and the number of likes (as a number, not text like "1.2k"). Return the data as a JSON object with a single key "comments". The value of "comments" should be an array of objects, where each object represents a single comment and has four keys: "author", "text", "timestamp", and "likes". If a value for likes is not visible, return 0. For example: { "comments": [{ "author": "user123", "text": "This is a great post!", "timestamp": "2h ago", "likes": 15 }] }. Do not include entries where the comment text is empty. If you cannot find any comments, return an empty array.`;
            const payload = {
                contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/png", data: imageData } }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "comments": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "author": { "type": "STRING" }, "text": { "type": "STRING" }, "timestamp": { "type": "STRING" }, "likes": { "type": "NUMBER" } }, "required": ["author", "text", "timestamp", "likes"] } } } } }
            };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`The AI service failed. Server said: ${errorBody}`);
            }
            const result = await response.json();
            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (jsonText) return JSON.parse(jsonText).comments;
            throw new Error('The AI could not find any comments in the image.');
        }

        async function callSentimentAPI(comments) {
            const apiKey = "AIzaSyDRo_7IcLRRKwqKhZtTE1-JtOu5Hb1ZRsY";
            const commentTexts = comments.map(c => c.text);
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const prompt = `Analyze the sentiment of the following list of comments. For each comment, classify it as 'Positive', 'Negative', or 'Neutral'. Also, provide an overall summary of the sentiment distribution as a "share of voice" (SOV). Return the data as a single JSON object with two keys: "sentiments" and "sov". The "sentiments" key should be an array of strings, one for each comment in the original order. The "sov" key should be an object with keys 'Positive', 'Negative', and 'Neutral', with their percentage values (as numbers, summing to 100). Example: { "sentiments": ["Positive", "Negative", "Neutral"], "sov": { "Positive": 60, "Negative": 25, "Neutral": 15 } }. Here are the comments: ${JSON.stringify(commentTexts)}`;
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "sentiments": { "type": "ARRAY", "items": { "type": "STRING" } }, "sov": { "type": "OBJECT", "properties": { "Positive": { "type": "NUMBER" }, "Negative": { "type": "NUMBER" }, "Neutral": { "type": "NUMBER" } } } } } }
            };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Google API Error for sentiment analysis: ${errorText}`);
            }
            const result = await response.json();
            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (jsonText) return JSON.parse(jsonText);
            throw new Error("Could not parse sentiment analysis response.");
        }

        async function pushToPulsar(comments, pulsarApiKey, targetSearchId) {
            const pulsarApiEndpoint = `https://api.pulsarplatform.com/v2/searches/${targetSearchId}/keywords`;
            const payload = { keywords_to_add: comments };
            const headers = { "Authorization": `Bearer ${pulsarApiKey}`, "Content-Type": "application/json" };
            const response = await fetch(pulsarApiEndpoint, { method: 'PUT', headers, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Failed to fetch. Server said: ${errorBody}`);
            }
        }

        // --- UI & Helper Functions ---
        function displayResults(comments, withSentiment = false) {
            let tableHTML = `<table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr><th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Author</th><th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Comment</th>`;
            if (withSentiment) {
                tableHTML += `<th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Sentiment</th>`;
            }
            tableHTML += `<th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Likes</th><th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th></tr></thead><tbody id="resultsTableBody" class="bg-white divide-y divide-gray-200">`;
            
            comments.forEach(comment => {
                tableHTML += `<tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${escapeHTML(comment.author)}</td><td class="px-6 py-4 whitespace-normal text-sm text-gray-500">${escapeHTML(comment.text)}</td>`;
                if (withSentiment) {
                    const sentimentColor = comment.sentiment === 'Positive' ? 'text-green-600' : comment.sentiment === 'Negative' ? 'text-red-600' : 'text-gray-500';
                    tableHTML += `<td class="px-6 py-4 whitespace-nowrap text-sm font-semibold ${sentimentColor}">${escapeHTML(comment.sentiment)}</td>`;
                }
                tableHTML += `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${escapeHTML(comment.likes)}</td><td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${escapeHTML(comment.timestamp)}</td></tr>`;
            });

            tableHTML += `</tbody></table>`;
            resultsTableContainer.innerHTML = tableHTML;

            statusText.textContent = withSentiment ? `Sentiment analysis complete.` : `Successfully extracted ${comments.length} comments.`;
            resultsSection.classList.remove('hidden');
            resultsSection.classList.add('fade-in-up');
        }
        
        function displaySov(sov) {
            const sentimentColors = { Positive: 'bg-green-500', Negative: 'bg-red-500', Neutral: 'bg-gray-400' };
            sovBars.innerHTML = '';
            for (const [sentiment, value] of Object.entries(sov)) {
                const bar = document.createElement('div');
                bar.className = 'w-full bg-gray-200 rounded-full h-4';
                bar.innerHTML = `<div class="${sentimentColors[sentiment]} h-4 rounded-full text-xs font-medium text-white text-center p-0.5 leading-none" style="width: ${value}%">${value}% ${sentiment}</div>`;
                sovBars.appendChild(bar);
            }
            sentimentSovContainer.classList.remove('hidden');
            sentimentSovContainer.classList.add('fade-in-up');
        }
        
        function resetUI() {
            imageUpload.value = '';
            imagePreview.src = '';
            base64ImageData = null;
            imageUploadTime = null;
            imagePreviewContainer.classList.add('hidden');
            extractBtn.disabled = true;
            resetResults();
        }

        function resetResults() {
            resultsSection.classList.add('hidden');
            sentimentSovContainer.classList.add('hidden');
            actionButtons.classList.remove('hidden');
            pulsarSection.classList.add('hidden');
            hideMessage();
        }

        function setLoading(button, textElement, loaderElement, isLoading, loadingText) {
            if (!textElement.dataset.originalText && isLoading) textElement.dataset.originalText = textElement.textContent;
            button.disabled = isLoading;
            textElement.textContent = isLoading ? loadingText : textElement.dataset.originalText;
            loaderElement.classList.toggle('hidden', !isLoading);
        }
        
        function showMessage(title, text, type = 'error') {
            messageTitle.textContent = title;
            messageText.textContent = text;
            messageBox.className = `mt-6 px-4 py-3 rounded-lg relative fade-in-up ${type === 'error' ? 'bg-red-100 border border-red-400 text-red-700' : 'bg-green-100 border border-green-400 text-green-700'}`;
            messageBox.classList.remove('hidden');
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        function escapeHTML(str) {
            if (typeof str !== 'string' && typeof str !== 'number') return '';
            return String(str).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]);
        }
        
        function parseRelativeTime(relativeString, referenceDate) {
            if (!relativeString) return "N/A";
            const now = new Date(referenceDate);
            const str = relativeString.toLowerCase().trim();
            let date = new Date(now);
            const matchers = [
                { regex: /(\d+)\s*s(ec)?/, unit: 'seconds' }, { regex: /(\d+)\s*m(in)?/, unit: 'minutes' },
                { regex: /(\d+)\s*h(r|our)?/, unit: 'hours' }, { regex: /(\d+)\s*d(ay)?/, unit: 'days' },
                { regex: /(\d+)\s*w(k|eek)?/, unit: 'weeks' }, { regex: /(\d+)\s*mo(nth)?/, unit: 'months' },
                { regex: /(\d+)\s*y(r|ear)?/, unit: 'years' }
            ];
            let matched = false;
            for (const { regex, unit } of matchers) {
                const match = str.match(regex);
                if (match) {
                    const value = parseInt(match[1], 10);
                    if (unit === 'seconds') date.setSeconds(date.getSeconds() - value);
                    if (unit === 'minutes') date.setMinutes(date.getMinutes() - value);
                    if (unit === 'hours') date.setHours(date.getHours() - value);
                    if (unit === 'days') date.setDate(date.getDate() - value);
                    if (unit === 'weeks') date.setDate(date.getDate() - value * 7);
                    if (unit === 'months') date.setMonth(date.getMonth() - value);
                    if (unit === 'years') date.setFullYear(date.getFullYear() - value);
                    matched = true;
                    break;
                }
            }
            if (str.includes("yesterday")) {
                date.setDate(date.getDate() - 1);
                matched = true;
            }
            if (!matched) {
                const parsedDate = new Date(str);
                if (!isNaN(parsedDate.getTime())) {
                    if (!/(\d{4})/.test(str)) {
                        parsedDate.setFullYear(now.getFullYear());
                        if (parsedDate > now) parsedDate.setFullYear(now.getFullYear() - 1);
                    }
                    date = parsedDate;
                } else { return relativeString; }
            }
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hour = String(date.getHours()).padStart(2, '0');
            const minute = String(date.getMinutes()).padStart(2, '0');
            const second = String(date.getSeconds()).padStart(2, '0');
            return `${day}/${month}/${year} ${hour}:${minute}:${second}`;
        }

        function generateCSV(withSentiment) {
            if (extractedComments.length === 0) {
                showMessage('Error', 'No comments to download.', 'error');
                return;
            }
            const escapeCSV = (field) => {
                if (field == null) return '';
                let str = String(field);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    str = str.replace(/"/g, '""');
                    return `"${str}"`;
                }
                return str;
            };
            
            const headers = ['Content ID', 'Date', 'Comment/Content', 'Author', 'Likes'];
            if (withSentiment) {
                headers.push('Sentiment');
            }

            const csvRows = [headers.join(',')];
            const commentsToExport = extractedComments.filter(comment => comment.text && comment.text.trim() !== '');

            commentsToExport.forEach(comment => {
                const contentId = crypto.randomUUID();
                const values = [
                    escapeCSV(contentId), escapeCSV(comment.timestamp),
                    escapeCSV(comment.text), escapeCSV(comment.author),
                    escapeCSV(comment.likes)
                ];
                if (withSentiment) {
                    values.push(escapeCSV(comment.sentiment || 'N/A'));
                }
                csvRows.push(values.join(','));
            });
            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = withSentiment ? 'sentiment-report.csv' : 'extracted-comments.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>

